{"name":"Metriclient","tagline":"Metriclient - Flexible event and error reporting server","body":"Metriclient\r\n===========\r\n\r\nFlexible event and error reporting server\r\n\r\n## About metriclient\r\n\r\nMetriclient is a specification for storing structured data to represent events\r\nand errors coming from your application. It comes bundled with a server to store\r\nthem, and a set of scripts to help you extract information from it.\r\n\r\nIt is designed to be an independent server that specializes on error\r\nrecollection. It plays well with [Lithium](https://github.com/azendal/lithium)\r\nand [Cobalt](https://github.com/benbeltran/cobalt), since they are designed for\r\nexecution tracing and message formatting themselves, but they are not required.\r\n\r\n## Events and errors\r\n\r\nEvents are the central component in metriclient. They are data records that\r\ncontain the information you want to track.\r\n\r\nThe structure of an event is:\r\n\r\n    id\r\n    event_type\r\n    created_at\r\n    updated_at\r\n\r\nErrors are no different than events, but are more specialized events that come\r\nwith more information about the errors on your application. They are recorded in\r\na different table, and have more fields that reflect the nature of an error or\r\ncan aid in detecting and debugging, such as `line`, `url` and `user_agent`\r\n\r\nThe fields for an error are:\r\n\r\n    id\r\n    url\r\n    frame\r\n    user_agent\r\n    scoped_class_name\r\n    meta\r\n    created_at\r\n    updated_at\r\n\r\n### Field description\r\n\r\n* `id`, `created_at`, `updated_at`: Standard sql id and timestamps\r\n* `event_type`: Send the name of the event you are interested in (e.g.:\r\n                'login_button:click').\r\n* `error`: String that holds the error message, passed from the client.\r\n* `url`: Intended for error catching in the frontend, this holds the url where\r\n         the error comes from.\r\n* `user_agent`: Also for frontend error catching, pass the user agent from where\r\n                the request originated.\r\n* `scoped_class_name`: When using Lithium error catching, this indicates the\r\n                       Neon class where it originated.\r\n* `frame`: Defines the scope or module in which the error generated, not\r\n           necessarily HTML frame but application frame.\r\n* `meta`: This can hold arbitrary data you want to send from your application.\r\n          The errors table saves the meta info as text, so it works best for\r\n          unstructured data (suck as error stack traces). For structured data,\r\n          you may want to look at the [Meta table](#meta-table)\r\n\r\n## <a name=\"meta-table\"></a> Meta table\r\n\r\nAside from the standard event fields, you can store any arbitrary structured\r\ndata in the `events_meta` table. The metriclient API does the extraction\r\nautomatically if you pass an object to the `meta` attribute\r\n\r\nThe `event_meta` table holds the following fields:\r\n\r\n* `id`: Standard sql id\r\n* `key`: The name of the key in the metadata\r\n* `value`: The value associated with the key coming from the metadata\r\n* `event_id`: Foreign key referencing the event from which this meta info comes\r\n              from\r\n\r\n## API\r\n\r\nThe metriclient API consists of the following methods\r\n\r\n### `POST /api/v1/events`\r\n\r\n#### Parameters:\r\n\r\n`event`: A JSON object containing all the required fields for the event. It can\r\n         also contain the special field `data`, to store metaadata related to\r\n         the event.\r\n\r\n### `POST /api/v1/errors`\r\n\r\n`event`: A JSON object containing all the required fields for the error.\r\n\r\nand the web view for errors\r\n\r\n### `GET /errors/:id`\r\n\r\nShows the json object of the record with that id\r\n\r\n#### Parameters:\r\n\r\n`id`: The id of the error record\r\n\r\n## Archiving\r\n\r\nThe metriclient server comes bundled with scripts for archiving, since it is\r\nexpected that you'd want to store a large number of events and errors.\r\n\r\nYou can use the rake tasks for manually making archive backups of your database,\r\nor integrate them with your deploy and provisioning system for scheduling them.\r\n\r\nThe data is archived in tables named `events_archive`, `events_meta_archive` and\r\n`errors_archive` with the same schema as the original tables.\r\n\r\nIt is recommended that you use an ARCHIVE storage engine for the database since\r\nthe archive is intended for read-only, there are no updates and inserts are on\r\ndemand\r\n\r\n## Examples\r\n\r\n\r\n    $ ./script/db/archive config/myproject.yml\r\n    $ ./script/db/clean   config/myproject.yml\r\n\r\n\r\n    # Example of myproject.yml:\r\n    # -------------------------------------------------------------------------\r\n    # host      : localhost\r\n    # database  : metriclient_dev\r\n    # username  : root\r\n    # password  :\r\n    # tables    :\r\n    #   archive:  [events, errors, event_meta]\r\n    #   clean:  [events, errors]\r\n    # -------------------------------------------------------------------------\r\n\r\n\r\nYou should add something similar to your provisioning engine.\r\nProbably in a cron or something, it is up to you to setup the right env though.\r\n\r\nNote: We recommend archiving every hour, and cleaning once a day.\r\n\r\nNote: MySQL dumps fall outside of this app's realm, you should provision that yourself!\r\n\r\n### Simple event tracking\r\n\r\nSend event info to the API, from a node.js client\r\n\r\n    var request = require(\"request\");\r\n\r\n    request({\r\n        uri : 'http://my.metriclient.server.com/events',\r\n        method: 'POST',\r\n        form: {\r\n            event: {\r\n                event_type: 'user:login',\r\n                data: {\r\n                    userId: 10,\r\n                    siteVersion: '1.0'\r\n                }\r\n            }\r\n        }\r\n    }, function(error, response, body) {\r\n        console.log(body);\r\n    });\r\n\r\n### Frontend Error tracking\r\n\r\nIn this example you can set up error catching and send detailed info to the\r\nserver. The example is using Lithium, but you can use it with try/catch or\r\nstandard onError events.\r\n\r\n    Li.Engine.error.push(function (data) {\r\n        var className = data.spy.targetObject.className || data.scope.constructor.className;\r\n        var methoName = data.spy.methodName;\r\n        $.post('http://my.metriclient.server.com/errors', {\r\n            data : {\r\n                event : {\r\n                    userAgent : navigator.userAgent,\r\n                    scopedClassName : className,\r\n                    error : data.error.message,\r\n                    meta : data.error.stack\r\n                }\r\n            },\r\n            success : { ... }\r\n        });\r\n    });\r\n\r\n## Installation\r\n\r\nFor installing, first you need to create your `config/database.yml` file, with\r\nyour database settings. The keys should be the name of your subdomains if want\r\nto have multiple projects reporting to different subdomains in the same server.\r\nFor using just one database without subdomains, you can use the `default` key.\r\n\r\n```yaml\r\ndefault:\r\n  development:\r\n    adapter: mysql2\r\n    database: database_name\r\n    username: user\r\n    password: 123abc\r\n    host: localhost\r\n  production:\r\n    adapter: mysql2\r\n    database: metriclient\r\n    username: root\r\n    password: 123abc\r\n    host: localhost\r\n\r\nother_subdomain:\r\n  development:\r\n    ...\r\n  production:\r\n    ...\r\n```\r\n\r\nThen you need to create the database and run the migrations\r\n\r\n```bash\r\n$ RACK_ENV=production rake db:create\r\n$ RACK_ENV=production rake db:migrate\r\n```\r\n\r\nThis will set up the database. Only thing left you need is to run the server,\r\nusing whatever web server you decide\r\n\r\n```bash\r\n$ RACK_ENV=production unicorn_rails -c config/unicorn.rb\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}